## Декораторы
### Задача 1: Продаём котиков

1.1 Написать декоратор, который перед запуском произвольной функции с произвольным набором аргументов будет показывать
в консоли сообщение "Покупайте наших котиков!" и возвращать результат запущенной функции.
1.2 Параметризовать декоратор таким образом, чтобы сообщение, печатаемое перед выполнением функции можно было задавать
как параметр во время декорирования.

### Задача 2: Ретрай-декоратор

2.1 Написать декоратор, который внутри себя выполнял бы функцию и возвращал бы результат её работы в случае успешного
выполнения. В случае возникновения ошибки во время выполнения функции нужно сделать так, чтобы выполнение функции было
повторено ещё раз с теми же самыми аргументами, но не более 10 раз. Если после последней попытки функцию так и не 
удастся выполнить успешно, то бросать исключение.
2.2 Параметризовать декоратор таким образом, чтобы количество попыток выполнения функции можно было задавать как 
параметр во время декорирования.

### Задача 3: Кжширование

3.1 Написать кэширующий декоратор. Суть в том, что если декорируемая функция будет запущена с теми параметрами с 
которыми она уже запускалась - брать результат из кэша и не производить повторное выполнение функции.
3.2 Сделать так, чтобы информация в кэше была актуальной не более 10 секунд. Предусмотреть механизм автоматической
очистки кэша в процессе выполнения функций.
3.3 Параметризовать время кэширования в декораторе.

### Задача 4: Измерение времени работы

4.1 Написать декоратор, который бы измерял время работы функции и печатал бы его на экран.
4.2 Доработать декоратор таким образом, чтобы в логах было название запускаемой функции помимо времени исполнения.
4.3 Доработать декоратор так, чтобы запись лога для функции велась в файл, путь к которому нужно было бы задавать
во время декорирования, как параметр.

### Задача 5: Сэндвич из декораторов

После решения задач написать функцию и задекорировать её сразу несколькими из созданных декораторов и посмотреть 
на результат и суметь объяснить его. Потом поменять порядок декорирования и проделать то же самое.

### Задача 6: Ввод пароля

6.1 Написать декоратор, который будет запрашивать у пользователя пароль при попытке функции осуществить вызов. Если 
введён верный пароль, то функция будет выполнена и вернется результат её работы. Если нет - в консоли появляется 
соответствующее сообщение.
6.2 Параметризовать декоратор таким образом, чтобы можно было задавать индивидуальный пароль для каждой декорируемой
функции.

### Задача 7: Реализация маршрутов с использованием декоратора
Реализуйте систему маршрутов для консольного приложения с использованием декоратора. Программа должна работать следующим образом:
- Пользователь вводит команду в формате:  
   ```bash
   /<route> <param1> <param2> ...
   ```
- У вас есть декоратор @route, который регистрирует функции, связанные с маршрутами. Например:
```
@route("/users")
def get_users(*args):
    print(f"Получены пользователи с параметрами: {args}")
```
- Когда пользователь вводит команду, программа должна определять маршрут и передавать параметры в соответствующую функцию.
- Если маршрут не зарегистрирован, программа должна выводить сообщение: "Маршрут не найден."
- Если маршрут зарегистрирован, программа должна вызывать соответствующую функцию с переданными параметрами.

Пример работы программы:
```/users 1 2 3```

Вывод:
```Получены пользователи с параметрами: ('1', '2', '3')```

Ввод:
```/orders 42```

Вывод:
```Маршрут не найден.```

Требования:
1.	Реализуйте декоратор @route, который регистрирует функции для обработки маршрутов.
2.	Реализуйте основной цикл программы, который принимает команды от пользователя и вызывает соответствующие функции.
3.	Обраб*отайте случай, если пользователь ввёл маршрут, который не зарегистрирован.
